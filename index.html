<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Sakura Tap — Demo</title>
  <style>
    :root{
      --gold:#d4a956;
      --text:#f7f3ea;
      --muted: rgba(247,243,234,.72);
      --panel: rgba(0,0,0,.35);
      --stroke: rgba(255,255,255,.16);
      --ok:#6ee7b7;
      --bad:#fb7185;
    }
    *{ box-sizing:border-box; }
    html,body{ margin:0; padding:0; height:100%; background:#000; color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    body{ overflow:hidden; touch-action:manipulation; }

    .bg{
      position:fixed; inset:0;
      background:
        linear-gradient(rgba(0,0,0,.18), rgba(0,0,0,.42)),
        url("assets/img/sakura-bg.png");
      background-size:cover;
      background-position:center;
      transform:scale(1.02);
      filter:saturate(1.05);
    }
    .vignette{
      position:fixed; inset:0;
      background: radial-gradient(circle at 50% 20%, rgba(255,255,255,.06), rgba(0,0,0,.65) 70%);
      pointer-events:none;
    }

    .hud{
      position:fixed; left:12px; right:12px; top:12px;
      display:flex; gap:10px; align-items:stretch; justify-content:space-between;
      pointer-events:none;
    }
    .hud .card{
      pointer-events:auto;
      background:var(--panel);
      border:1px solid var(--stroke);
      backdrop-filter: blur(6px);
      border-radius:16px;
      padding:10px 12px;
      display:flex; gap:10px; align-items:center;
      min-width: 160px;
    }
    .hud .title{ font-size:12px; color:var(--muted); margin-bottom:2px; }
    .hud .value{ font-size:18px; font-weight:750; letter-spacing:.2px; }
    .hud .right{ text-align:right; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(212,169,86,.35);
      background:rgba(0,0,0,.25);
      color:var(--muted);
      font-size:12px;
      pointer-events:auto;
      user-select:none;
    }
    .pill b{ color:var(--gold); }

    .centerPanel{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:20px;
      pointer-events:none;
    }
    .modal{
      pointer-events:auto;
      width:min(520px, 92vw);
      background:rgba(0,0,0,.45);
      border:1px solid var(--stroke);
      backdrop-filter: blur(10px);
      border-radius:22px;
      padding:18px;
      box-shadow: 0 22px 70px rgba(0,0,0,.55);
    }
    h1{ margin:0 0 8px 0; font-size:22px; }
    p{ margin:0 0 10px 0; color:var(--muted); line-height:1.45; font-size:13px; }
    .rules{
      display:grid; gap:8px; margin:12px 0 14px 0;
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:12px;
      background:rgba(255,255,255,.04);
    }
    .ruleRow{ display:flex; justify-content:space-between; gap:10px; color:var(--muted); font-size:13px; }
    .ruleRow b{ color:var(--text); font-weight:650; }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      appearance:none;
      border:1px solid rgba(212,169,86,.45);
      background:rgba(0,0,0,.35);
      color:var(--text);
      padding:11px 14px;
      border-radius:14px;
      cursor:pointer;
      font-weight:650;
      letter-spacing:.2px;
    }
    button:hover{ background:rgba(212,169,86,.10); }
    .ghost{
      border-color:rgba(255,255,255,.18);
    }
    .ghost:hover{ background:rgba(255,255,255,.06); }

    .note{
      margin-top:10px;
      font-size:12px;
      color:rgba(247,243,234,.55);
    }

    .field{ position:fixed; inset:0; overflow:hidden; }

    .petal{
      position:absolute;
      width:64px; height:64px;
      border-radius: 16px 46px 16px 46px;
      transform: rotate(18deg);
      background:
        radial-gradient(circle at 35% 30%, rgba(255,255,255,.95), rgba(255,255,255,.0) 55%),
        radial-gradient(circle at 30% 25%, rgba(255,183,210,.95), rgba(255,183,210,.15) 62%),
        linear-gradient(140deg, rgba(255,210,230,.85), rgba(255,150,190,.55));
      box-shadow:
        0 10px 26px rgba(0,0,0,.25),
        inset 0 1px 0 rgba(255,255,255,.35);
      border:1px solid rgba(255,255,255,.20);
      opacity:.95;
      transition: transform 120ms ease, filter 120ms ease, opacity 120ms ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .petal::after{
      content:"";
      position:absolute; inset:10px;
      border-radius: 14px 40px 14px 40px;
      background: radial-gradient(circle at 45% 40%, rgba(255,255,255,.65), rgba(255,255,255,0) 60%);
      opacity:.45;
      transform: rotate(-10deg);
    }

    /* Highlighted target */
    .target{
      border-color: rgba(212,169,86,.7);
      filter: drop-shadow(0 0 12px rgba(212,169,86,.55)) drop-shadow(0 0 28px rgba(255,255,255,.12));
      animation: pulse 760ms ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{ transform: scale(1) rotate(18deg); }
      50%{ transform: scale(1.08) rotate(18deg); }
    }

    /* Wrong tap feedback (ignored tap) */
    .wrongFlash{
      animation: wrong 220ms ease-in-out 1;
    }
    @keyframes wrong{
      0%{ filter:none; }
      30%{ filter: drop-shadow(0 0 14px rgba(251,113,133,.65)); }
      100%{ filter:none; }
    }

    .spark{
      position:absolute;
      width:8px; height:8px;
      border-radius:999px;
      background:rgba(255,255,255,.9);
      box-shadow: 0 0 14px rgba(255,255,255,.35);
      pointer-events:none;
      opacity:.9;
      transform: translate(-50%,-50%);
      animation: pop 520ms ease-out forwards;
    }
    @keyframes pop{
      0%{ opacity:.95; transform: translate(-50%,-50%) scale(1); }
      100%{ opacity:0; transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(.2); }
    }

    .prizeBig{
      font-size:18px;
      font-weight:800;
      color:var(--ok);
      margin-top:8px;
    }
    .prizeBig.bad{ color:var(--bad); }

    .hidden{ display:none !important; }
  </style>
</head>
<body>
  <div class="bg"></div>
  <div class="vignette"></div>

  <div class="field" id="field"></div>

  <div class="hud">
    <div class="card">
      <div>
        <div class="title">Score</div>
        <div class="value" id="score">0</div>
      </div>
    </div>

    <div class="pill">Rule: <b>Tap ONLY highlighted</b></div>

    <div class="card right">
      <div>
        <div class="title">Time</div>
        <div class="value"><span id="time">15.0</span>s</div>
      </div>
    </div>
  </div>

  <div class="centerPanel" id="overlay">
    <div class="modal" id="modal">
      <h1>Sakura Tap (15s)</h1>
      <p><b style="color:var(--gold)">Tap only on the highlighted petals.</b> Other taps are ignored. The game becomes harder as it goes on.</p>

      <div class="rules">
        <div class="ruleRow"><span>18–24</span> <b>Free miso soup</b></div>
        <div class="ruleRow"><span>25–29</span> <b>50% next purchase</b></div>
        <div class="ruleRow"><span>30+</span> <b>Free katsu curry</b></div>
      </div>

      <div class="btnRow">
        <button id="startBtn">Start</button>
        <button class="ghost" id="muteBtn">Sound: ON</button>
      </div>

      <div class="note">
        Difficulty scaling: smaller target + more decoys + faster switching + movement (hard to reach 25, brutal to reach 30).
      </div>
    </div>
  </div>

  <script>
    const GAME_SECONDS = 15.0;

    function getPhase(elapsed){
      if(elapsed < 5) return "EASY";
      if(elapsed < 10) return "MED";
      return "HARD";
    }

    const PHASE_SETTINGS = {
      EASY: { label:"Easy",   petals:5,  targetSize:70, decoySize:64, switchMs:900, move:false, moveSpeed:0 },
      MED:  { label:"Medium", petals:7,  targetSize:56, decoySize:52, switchMs:700, move:true,  moveSpeed:0.55 },
      HARD: { label:"Hard",   petals:10, targetSize:46, decoySize:42, switchMs:520, move:true,  moveSpeed:0.95 }
    };

    // Anti-farm (keeps 30 very hard)
    const GLOBAL_TAP_COOLDOWN_MS = 95;

    const field = document.getElementById("field");
    const overlay = document.getElementById("overlay");
    const startBtn = document.getElementById("startBtn");
    const muteBtn = document.getElementById("muteBtn");
    const scoreEl = document.getElementById("score");
    const timeEl = document.getElementById("time");
    const modal = document.getElementById("modal");

    let running = false;
    let soundOn = true;

    let score = 0;
    let remaining = GAME_SECONDS;
    let startTs = 0;
    let rafId = null;

    let petals = [];
    let targetIndex = -1;
    let switchTimer = null;

    let lastTapAt = 0;

    // SOUND
    let audioCtx = null;
    function ensureAudio(){
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if(audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    }
    function tapSound(ok){
      if(!soundOn) return;
      ensureAudio();
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();

      const freq = ok ? 880 : 220;
      o.type = "triangle";
      o.frequency.setValueAtTime(freq, t);
      o.frequency.exponentialRampToValueAtTime(freq * (ok ? 1.6 : 1.2), t + 0.05);

      g.gain.setValueAtTime(ok ? 0.07 : 0.10, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.07);

      o.connect(g); g.connect(audioCtx.destination);
      o.start(t); o.stop(t + 0.08);
    }

    function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
    function rand(min,max){ return Math.random()*(max-min)+min; }
    function viewport(){ return { w: window.innerWidth, h: window.innerHeight }; }

    function setScore(n){
      score = Math.max(0, n);
      scoreEl.textContent = score;
    }
    function setTime(sec){
      timeEl.textContent = sec.toFixed(1);
    }

    function spawnSpark(x, y, ok){
      const s = document.createElement("div");
      s.className = "spark";
      s.style.left = x + "px";
      s.style.top = y + "px";
      s.style.background = ok ? "rgba(255,255,255,.95)" : "rgba(251,113,133,.95)";
      s.style.setProperty("--dx", (rand(-26, 26)).toFixed(0) + "px");
      s.style.setProperty("--dy", (rand(-40, -10)).toFixed(0) + "px");
      field.appendChild(s);
      setTimeout(()=> s.remove(), 560);
    }

    function clearField(){
      field.innerHTML = "";
      petals = [];
      targetIndex = -1;
    }

    function createPetal(){
      const el = document.createElement("div");
      el.className = "petal";
      el.dataset.isTarget = "0";
      el._x = 0; el._y = 0;
      el._vx = 0; el._vy = 0;
      field.appendChild(el);
      return el;
    }

    function placePetal(el, size){
      const { w, h } = viewport();
      const pad = 18;
      const topSafe = 78;

      el.style.width = size + "px";
      el.style.height = size + "px";

      const x = rand(pad, w - pad - size);
      const y = rand(topSafe, h - pad - size);
      el._x = x; el._y = y;

      el.style.left = x + "px";
      el.style.top = y + "px";

      const rot = rand(-40, 40);
      el.style.transform = `rotate(${rot}deg)`;
      el._rot = rot;
    }

    function applyTarget(idx, phase){
      const cfg = PHASE_SETTINGS[phase];
      petals.forEach((p, i) => {
        const isT = i === idx;
        p.classList.toggle("target", isT);
        p.dataset.isTarget = isT ? "1" : "0";

        const size = isT ? cfg.targetSize : cfg.decoySize;
        p.style.width = size + "px";
        p.style.height = size + "px";
      });
    }

    function scheduleTargetSwitch(){
      if(!running) return;

      const elapsed = (performance.now() - startTs) / 1000;
      const phase = getPhase(elapsed);
      const cfg = PHASE_SETTINGS[phase];

      clearTimeout(switchTimer);
      switchTimer = setTimeout(() => {
        if(!running) return;

        let next = Math.floor(Math.random() * petals.length);
        if(next === targetIndex && petals.length > 1) next = (next + 1) % petals.length;
        targetIndex = next;
        applyTarget(targetIndex, phase);

        // chaos boost in HARD: teleport some petals (including decoys)
        if(phase === "HARD"){
          const moves = Math.floor(rand(2, 5));
          for(let i=0;i<moves;i++){
            const j = Math.floor(Math.random() * petals.length);
            const isTarget = (j === targetIndex);
            placePetal(petals[j], isTarget ? cfg.targetSize : cfg.decoySize);
          }
        }

        scheduleTargetSwitch();
      }, cfg.switchMs);
    }

    function initPetalsForPhase(phase){
      clearTimeout(switchTimer);
      switchTimer = null;

      const cfg = PHASE_SETTINGS[phase];

      clearField();
      for(let i=0;i<cfg.petals;i++){
        const p = createPetal();
        petals.push(p);
      }

      for(let i=0;i<petals.length;i++){
        placePetal(petals[i], cfg.decoySize);

        if(cfg.move){
          petals[i]._vx = rand(-1, 1) * cfg.moveSpeed;
          petals[i]._vy = rand(-1, 1) * cfg.moveSpeed;
        }else{
          petals[i]._vx = 0; petals[i]._vy = 0;
        }
      }

      targetIndex = Math.floor(Math.random() * petals.length);
      applyTarget(targetIndex, phase);

      // IMPORTANT: only target counts
      petals.forEach((el, idx) => {
        el.onclick = (e) => handleTap(e, idx);
      });

      scheduleTargetSwitch();
    }

    function movePetals(){
      const elapsed = (performance.now() - startTs) / 1000;
      const phase = getPhase(elapsed);
      const cfg = PHASE_SETTINGS[phase];
      if(!cfg.move) return;

      const { w, h } = viewport();
      const pad = 10;
      const topSafe = 76;

      for(const p of petals){
        const size = parseFloat(getComputedStyle(p).width) || 50;

        p._x += p._vx;
        p._y += p._vy;

        if(phase === "HARD"){
          p._x += rand(-0.35, 0.35);
          p._y += rand(-0.25, 0.25);
        }

        if(p._x < pad){ p._x = pad; p._vx *= -1; }
        if(p._x > w - pad - size){ p._x = w - pad - size; p._vx *= -1; }
        if(p._y < topSafe){ p._y = topSafe; p._vy *= -1; }
        if(p._y > h - pad - size){ p._y = h - pad - size; p._vy *= -1; }

        p.style.left = p._x + "px";
        p.style.top = p._y + "px";
      }
    }

    /* STEP 2 IMPLEMENTED:
       ✅ Tap only on the highlighted petals
       - if tap is NOT target: IGNORE (no score change, optional error feedback)
    */
    function handleTap(ev, idx){
      if(!running) return;

      const now = performance.now();
      if(now - lastTapAt < GLOBAL_TAP_COOLDOWN_MS) return;
      lastTapAt = now;

      const elapsed = (performance.now() - startTs) / 1000;
      const phase = getPhase(elapsed);

      const isTarget = (idx === targetIndex);

      const rect = petals[idx].getBoundingClientRect();
      const x = rect.left + rect.width/2;
      const y = rect.top + rect.height/2;

      if(!isTarget){
        // IGNORE tap (rule)
        tapSound(false);
        spawnSpark(x, y, false);
        petals[idx].classList.add("wrongFlash");
        setTimeout(()=> petals[idx].classList.remove("wrongFlash"), 240);
        return;
      }

      // target tap counts
      tapSound(true);
      spawnSpark(x, y, true);
      setScore(score + 1);

      // make harder: in MED/HARD switch instantly after each correct tap
      if(phase !== "EASY"){
        let next = Math.floor(Math.random() * petals.length);
        if(next === targetIndex && petals.length > 1) next = (next + 1) % petals.length;
        targetIndex = next;
        applyTarget(targetIndex, phase);

        if(phase === "HARD"){
          for(let k=0;k<3;k++){
            const j = Math.floor(Math.random() * petals.length);
            const isT = (j === targetIndex);
            const cfg = PHASE_SETTINGS[phase];
            placePetal(petals[j], isT ? cfg.targetSize : cfg.decoySize);
          }
        }
      }
    }

    function startGame(){
      ensureAudio();

      running = true;
      overlay.classList.add("hidden");

      setScore(0);
      remaining = GAME_SECONDS;
      setTime(remaining);

      startTs = performance.now();
      lastTapAt = 0;

      const phase = getPhase(0);
      initPetalsForPhase(phase);

      const tick = () => {
        if(!running) return;

        const now = performance.now();
        const elapsed = (now - startTs) / 1000;

        remaining = clamp(GAME_SECONDS - elapsed, 0, GAME_SECONDS);
        setTime(remaining);

        movePetals();

        // rebuild at phase boundaries so difficulty jumps clearly
        if(Math.abs(elapsed - 5) < 0.016 || Math.abs(elapsed - 10) < 0.016){
          initPetalsForPhase(getPhase(elapsed));
        }

        if(remaining <= 0.001){
          endGame();
          return;
        }
        rafId = requestAnimationFrame(tick);
      };
      rafId = requestAnimationFrame(tick);
    }

    function getPrizeForScore(s){
      if(s >= 30) return { ok:true, name:"Free katsu curry", msg:"Congratulations! You won a free katsu curry to collect now in store." };
      if(s >= 25) return { ok:true, name:"50% next purchase", msg:"Congratulations! You won 50% off your next purchase to collect now in store." };
      if(s >= 18) return { ok:true, name:"Free miso soup", msg:"Congratulations! You won a free miso soup to collect now in store." };
      return { ok:false, name:"No prize this time", msg:"Try again — tap ONLY the highlighted petals!" };
    }

    function endGame(){
      running = false;
      cancelAnimationFrame(rafId);
      clearTimeout(switchTimer);

      const prize = getPrizeForScore(score);

      overlay.classList.remove("hidden");
      modal.innerHTML = `
        <h1>Time’s up!</h1>
        <p class="muted">Final score: <b style="color:var(--gold)">${score}</b></p>

        <div class="rules" style="margin-top:12px">
          <div class="ruleRow"><span>18–24</span> <b>Free miso soup</b></div>
          <div class="ruleRow"><span>25–29</span> <b>50% next purchase</b></div>
          <div class="ruleRow"><span>30+</span> <b>Free katsu curry</b></div>
        </div>

        <div class="prizeBig ${prize.ok ? "" : "bad"}">${prize.ok ? prize.name : "No prize"}</div>
        <p style="margin-top:8px">${prize.msg}</p>

        <div class="btnRow" style="margin-top:12px">
          <button id="restartBtn">Play again</button>
          <button class="ghost" id="muteBtn2">Sound: ${soundOn ? "ON" : "OFF"}</button>
        </div>

        <div class="note">Rule enforced: ONLY taps on highlighted petals count.</div>
      `;

      document.getElementById("restartBtn").onclick = () => {
        clearField();
        startGame();
      };
      document.getElementById("muteBtn2").onclick = () => toggleSound(document.getElementById("muteBtn2"));
    }

    function toggleSound(btn){
      soundOn = !soundOn;
      if(btn) btn.textContent = `Sound: ${soundOn ? "ON" : "OFF"}`;
      muteBtn.textContent = `Sound: ${soundOn ? "ON" : "OFF"}`;
    }

    startBtn.addEventListener("click", startGame);
    muteBtn.addEventListener("click", () => toggleSound(muteBtn));

    window.addEventListener("resize", () => {
      if(!running) return;
      const elapsed = (performance.now() - startTs) / 1000;
      const phase = getPhase(elapsed);
      const cfg = PHASE_SETTINGS[phase];
      petals.forEach((p, i) => {
        const size = (i === targetIndex) ? cfg.targetSize : cfg.decoySize;
        placePetal(p, size);
      });
    });
  </script>
</body>
</html>
